// Code generated by wit-bindgen-go. DO NOT EDIT.

// Package keyvalue represents the imported interface "fermyon:spin/key-value@2.0.0".
package keyvalue

import (
	"go.bytecodealliance.org/cm"
)

// Store represents the imported resource "fermyon:spin/key-value@2.0.0#store".
//
// An open key-value store
//
//	resource store
type Store cm.Resource

// ResourceDrop represents the imported resource-drop for resource "store".
//
// Drops a resource handle.
//
//go:nosplit
func (self Store) ResourceDrop() {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_StoreResourceDrop((uint32)(self0))
	return
}

// StoreOpen represents the imported static function "open".
//
// Open the store with the specified label.
//
// `label` must refer to a store allowed in the spin.toml manifest.
//
// `error::no-such-store` will be raised if the `label` is not recognized.
//
//	open: static func(label: string) -> result<store, error>
//
//go:nosplit
func StoreOpen(label string) (result cm.Result[ErrorShape, Store, Error]) {
	label0, label1 := cm.LowerString(label)
	wasmimport_StoreOpen((*uint8)(label0), (uint32)(label1), &result)
	return
}

// Delete represents the imported method "delete".
//
// Delete the tuple with the specified `key`
//
// No error is raised if a tuple did not previously exist for `key`.
//
//	delete: func(key: string) -> result<_, error>
//
//go:nosplit
func (self Store) Delete(key string) (result cm.Result[Error, struct{}, Error]) {
	self0 := cm.Reinterpret[uint32](self)
	key0, key1 := cm.LowerString(key)
	wasmimport_StoreDelete((uint32)(self0), (*uint8)(key0), (uint32)(key1), &result)
	return
}

// Exists represents the imported method "exists".
//
// Return whether a tuple exists for the specified `key`
//
//	exists: func(key: string) -> result<bool, error>
//
//go:nosplit
func (self Store) Exists(key string) (result cm.Result[ErrorShape, bool, Error]) {
	self0 := cm.Reinterpret[uint32](self)
	key0, key1 := cm.LowerString(key)
	wasmimport_StoreExists((uint32)(self0), (*uint8)(key0), (uint32)(key1), &result)
	return
}

// Get represents the imported method "get".
//
// Get the value associated with the specified `key`
//
// Returns `ok(none)` if the key does not exist.
//
//	get: func(key: string) -> result<option<list<u8>>, error>
//
//go:nosplit
func (self Store) Get(key string) (result cm.Result[OptionListU8Shape, cm.Option[cm.List[uint8]], Error]) {
	self0 := cm.Reinterpret[uint32](self)
	key0, key1 := cm.LowerString(key)
	wasmimport_StoreGet((uint32)(self0), (*uint8)(key0), (uint32)(key1), &result)
	return
}

// GetKeys represents the imported method "get-keys".
//
// Return a list of all the keys
//
//	get-keys: func() -> result<list<string>, error>
//
//go:nosplit
func (self Store) GetKeys() (result cm.Result[ErrorShape, cm.List[string], Error]) {
	self0 := cm.Reinterpret[uint32](self)
	wasmimport_StoreGetKeys((uint32)(self0), &result)
	return
}

// Set represents the imported method "set".
//
// Set the `value` associated with the specified `key` overwriting any existing value.
//
//	set: func(key: string, value: list<u8>) -> result<_, error>
//
//go:nosplit
func (self Store) Set(key string, value cm.List[uint8]) (result cm.Result[Error, struct{}, Error]) {
	self0 := cm.Reinterpret[uint32](self)
	key0, key1 := cm.LowerString(key)
	value0, value1 := cm.LowerList(value)
	wasmimport_StoreSet((uint32)(self0), (*uint8)(key0), (uint32)(key1), (*uint8)(value0), (uint32)(value1), &result)
	return
}

// Error represents the variant "fermyon:spin/key-value@2.0.0#error".
//
// The set of errors which may be raised by functions in this interface
//
//	variant error {
//		store-table-full,
//		no-such-store,
//		access-denied,
//		other(string),
//	}
type Error cm.Variant[uint8, string, string]

// ErrorStoreTableFull returns a [Error] of case "store-table-full".
//
// Too many stores have been opened simultaneously. Closing one or more
// stores prior to retrying may address this.
func ErrorStoreTableFull() Error {
	var data struct{}
	return cm.New[Error](0, data)
}

// StoreTableFull returns true if [Error] represents the variant case "store-table-full".
func (self *Error) StoreTableFull() bool {
	return self.Tag() == 0
}

// ErrorNoSuchStore returns a [Error] of case "no-such-store".
//
// The host does not recognize the store label requested.
func ErrorNoSuchStore() Error {
	var data struct{}
	return cm.New[Error](1, data)
}

// NoSuchStore returns true if [Error] represents the variant case "no-such-store".
func (self *Error) NoSuchStore() bool {
	return self.Tag() == 1
}

// ErrorAccessDenied returns a [Error] of case "access-denied".
//
// The requesting component does not have access to the specified store
// (which may or may not exist).
func ErrorAccessDenied() Error {
	var data struct{}
	return cm.New[Error](2, data)
}

// AccessDenied returns true if [Error] represents the variant case "access-denied".
func (self *Error) AccessDenied() bool {
	return self.Tag() == 2
}

// ErrorOther returns a [Error] of case "other".
//
// Some implementation-specific error has occurred (e.g. I/O)
func ErrorOther(data string) Error {
	return cm.New[Error](3, data)
}

// Other returns a non-nil *[string] if [Error] represents the variant case "other".
func (self *Error) Other() *string {
	return cm.Case[string](self, 3)
}

var stringsError = [4]string{
	"store-table-full",
	"no-such-store",
	"access-denied",
	"other",
}

// String implements [fmt.Stringer], returning the variant case name of v.
func (v Error) String() string {
	return stringsError[v.Tag()]
}
