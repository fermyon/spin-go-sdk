package fermyon:spin;

interface config {
	variant error {
		provider(string),
		invalid-key(string),
		invalid-schema(string),
		other(string),
	}

	/// Get a configuration value for the current component.
	/// The config key must match one defined in in the component manifest.
	get-config: func(key: string) -> result<string, error>;
}

interface http-types {
	type http-status = u16;
	type body = list<u8>;
	type headers = list<tuple<string, string>>;
	type params = list<tuple<string, string>>;
	type uri = string;
	enum method {
		get,
		post,
		put,
		delete,
		patch,
		head,
		options
	}
	record request {
		method: method,
		uri: uri,
		headers: headers,
		params: params,
		body: option<body>,
	}
	record response {
		status: http-status,
		headers: option<headers>,
		body: option<body>,
	}
	enum http-error {
		success,
		destination-not-allowed,
		invalid-url,
		request-error,
		runtime-error,
		too-many-requests
	}
}

interface http {
	use http-types.{request};
	use http-types.{response};
	use http-types.{http-error};
	send-request: func(req: request) -> result<response, http-error>;
}

interface inbound-http {
	use http-types.{request};
	use http-types.{response};
	handle-request: func(req: request) -> response;
}

interface key-value {
	/// A handle to an open key-value store
	type store = u32;

	/// The set of errors which may be raised by functions in this interface
	variant error {
		/// Too many stores have been opened simultaneously. Closing one or more
		/// stores prior to retrying may address this.
		store-table-full,
		/// The host does not recognize the store name requested.  Defining and
		/// configuring a store with that name in a runtime configuration file
		/// may address this.
		no-such-store,
		/// The requesting component does not have access to the specified store
		/// (which may or may not exist).
		access-denied,
		/// The store handle provided is not recognized, i.e. it was either never
		/// opened or has been closed.
		invalid-store,
		/// No key-value tuple exists for the specified key in the specified
		/// store.
		no-such-key,
		/// Some implementation-specific error has occurred (e.g. I/O)
		io(string),
	}

	/// Open the store with the specified name.
	///
	/// If `name` is "default", the default store is opened.  Otherwise,
	/// `name` must refer to a store defined and configured in a runtime
	/// configuration file supplied with the application.
	///
	/// `error::no-such-store` will be raised if the `name` is not recognized.
	open: func(name: string) -> result<store, error>;

	/// Get the value associated with the specified `key` from the specified
	/// `store`.
	///
	/// `error::invalid-store` will be raised if `store` is not a valid handle
	/// to an open store, and `error::no-such-key` will be raised if there is no
	/// tuple for `key` in `store`.
	get: func(store: store, key: string) -> result<list<u8>, error>;

	/// Set the `value` associated with the specified `key` in the specified
	/// `store`, overwriting any existing value.
	///
	/// `error::invalid-store` will be raised if `store` is not a valid handle
	/// to an open store.
	set: func(store: store, key: string, value: list<u8>) -> result<_, error>;

	/// Delete the tuple with the specified `key` from the specified `store`.
	///
	/// `error::invalid-store` will be raised if `store` is not a valid handle
	/// to an open store.  No error is raised if a tuple did not previously
	/// exist for `key`.
	delete: func(store: store, key: string) -> result<_, error>;

	/// Return whether a tuple exists for the specified `key` in the specified
	/// `store`.
	///
	/// `error::invalid-store` will be raised if `store` is not a valid handle
	/// to an open store.
	exists: func(store: store, key: string) -> result<bool, error>;

	/// Return a list of all the keys in the specified `store`.
	///
	/// `error::invalid-store` will be raised if `store` is not a valid handle
	/// to an open store.
	get-keys: func(store: store) -> result<list<string>, error>;

	/// Close the specified `store`.
	///
	/// This has no effect if `store` is not a valid handle to an open store.
	close: func(store: store);
}

/// A WASI interface dedicated to performing inferencing for Large Language Models.
interface llm {
	/// A Large Language Model.
	type inferencing-model = string;

	/// Inference request parameters
	record inferencing-params {
		/// The maximum tokens that should be inferred.
		///
		/// Note: the backing implementation may return less tokens.
		max-tokens: u32,
		/// The amount the model should avoid repeating tokens.
		repeat-penalty: f32,
		/// The number of tokens the model should apply the repeat penalty to.
		repeat-penalty-last-n-token-count: u32,
		/// The randomness with which the next token is selected.
		temperature: f32,
		/// The number of possible next tokens the model will choose from.
		top-k: u32,
		/// The probability total of next tokens the model will choose from.
		top-p: f32,
	}

	/// The set of errors which may be raised by functions in this interface
	variant error {
		model-not-supported,
		runtime-error(string),
		invalid-input(string),
	}

	/// Usage information related to the inferencing result
	record inferencing-usage {
		/// Number of tokens in the prompt
		prompt-token-count: u32,
		/// Number of tokens generated by the inferencing operation
		generated-token-count: u32,
	}

	/// An inferencing result
	record inferencing-result {
		/// The text generated by the model
		/// TODO: this should be a stream
		text: string,
		/// Usage information about the inferencing request
		usage: inferencing-usage,
	}

	/// The model used for generating embeddings
	type embedding-model = string;

	/// Usage related to an embeddings generation request
	record embeddings-usage {
		/// Number of tokens in the prompt
		prompt-token-count: u32,
	}

	/// Result of generating embeddings
	record embeddings-result {
		/// The embeddings generated by the request
		embeddings: list<list<f32>>,
		/// Usage related to the embeddings generation request
		usage: embeddings-usage,
	}

	/// Perform inferencing using the provided model and prompt with the given optional
	/// params
	infer: func(model: inferencing-model, prompt: string, params: option<inferencing-params>) -> result<inferencing-result, error>;

	/// Generate embeddings for the supplied list of text
	generate-embeddings: func(model: embedding-model, text: list<string>) -> result<embeddings-result, error>;
}

interface rdbms-types {
	enum db-data-type {
		boolean,
		int8,
		int16,
		int32,
		int64,
		uint8,
		uint16,
		uint32,
		uint64,
		floating32,
		floating64,
		str,
		binary,
		other
	}
	variant db-value {
		boolean(bool),
		int8(s8),
		int16(s16),
		int32(s32),
		int64(s64),
		uint8(u8),
		uint16(u16),
		uint32(u32),
		uint64(u64),
		floating32(f32),
		floating64(f64),
		str(string),
		binary(list<u8>),
		db-null,
		unsupported,
	}
	variant parameter-value {
		boolean(bool),
		int8(s8),
		int16(s16),
		int32(s32),
		int64(s64),
		uint8(u8),
		uint16(u16),
		uint32(u32),
		uint64(u64),
		floating32(f32),
		floating64(f64),
		str(string),
		binary(list<u8>),
		db-null,
	}
	record column {
		name: string,
		data-type: db-data-type,
	}
	type row = list<db-value>;
	record row-set {
		columns: list<column>,
		rows: list<row>,
	}
}

interface mysql {
	use rdbms-types.{parameter-value};
	use rdbms-types.{row-set};

	/// General purpose error.
	variant mysql-error {
		success,
		connection-failed(string),
		bad-parameter(string),
		query-failed(string),
		value-conversion-failed(string),
		other-error(string),
	}

	/// query the database: select
	query: func(address: string, statement: string, params: list<parameter-value>) -> result<row-set, mysql-error>;

	/// execute command to the database: insert, update, delete
	execute: func(address: string, statement: string, params: list<parameter-value>) -> result<_, mysql-error>;
}

interface postgres {
	use rdbms-types.{parameter-value};
	use rdbms-types.{row-set};

	/// General purpose error.
	variant pg-error {
		success,
		connection-failed(string),
		bad-parameter(string),
		query-failed(string),
		value-conversion-failed(string),
		other-error(string),
	}

	/// query the database: select
	query: func(address: string, statement: string, params: list<parameter-value>) -> result<row-set, pg-error>;

	/// execute command to the database: insert, update, delete
	execute: func(address: string, statement: string, params: list<parameter-value>) -> result<u64, pg-error>;
}

interface redis-types {
	/// General purpose error.
	enum error { success, error }

	/// The message payload.
	type payload = list<u8>;

	/// A parameter type for the general-purpose `execute` function.
	variant redis-parameter {
		int64(s64),
		binary(payload),
	}

	/// A return type for the general-purpose `execute` function.
	variant redis-result {
		nil,
		status(string),
		int64(s64),
		binary(payload),
	}
}

interface redis {
	use redis-types.{payload};
	use redis-types.{redis-parameter};
	use redis-types.{redis-result};
	use redis-types.{error};

	/// Publish a Redis message to the specificed channel and return an error, if any.
	publish: func(address: string, channel: string, payload: payload) -> result<_, error>;

	/// Get the value of a key.
	get: func(address: string, key: string) -> result<payload, error>;

	/// Set key to value. If key alreads holds a value, it is overwritten.
	set: func(address: string, key: string, value: payload) -> result<_, error>;

	/// Increments the number stored at key by one. If the key does not exist, it is set
	/// to 0 before performing the operation.
	/// An error is returned if the key contains a value of the wrong type or contains
	/// a string that can not be represented as integer.
	incr: func(address: string, key: string) -> result<s64, error>;

	/// Removes the specified keys. A key is ignored if it does not exist.
	del: func(address: string, keys: list<string>) -> result<s64, error>;

	/// Add the specified `values` to the set named `key`, returning the number of newly-added
	/// values.
	sadd: func(address: string, key: string, values: list<string>) -> result<s64, error>;

	/// Retrieve the contents of the set named `key`.
	smembers: func(address: string, key: string) -> result<list<string>, error>;

	/// Remove the specified `values` from the set named `key`, returning the number of
	/// newly-removed values.
	srem: func(address: string, key: string, values: list<string>) -> result<s64, error>;

	/// Execute an arbitrary Redis command and receive the result.
	execute: func(address: string, command: string, arguments: list<redis-parameter>) -> result<list<redis-result>, error>;
}

interface sqlite {
	/// A handle to an open sqlite instance
	type connection = u32;

	/// The set of errors which may be raised by functions in this interface
	variant error {
		/// The host does not recognize the database name requested.
		no-such-database,
		/// The requesting component does not have access to the specified database (which
		/// may or may not exist).
		access-denied,
		/// The provided connection is not valid
		invalid-connection,
		/// The database has reached its capacity
		database-full,
		/// Some implementation-specific error has occurred (e.g. I/O)
		io(string),
	}
	variant value {
		integer(s64),
		real(f64),
		text(string),
		blob(list<u8>),
		null,
	}

	/// A set of values for each of the columns in a query-result
	record row-result { values: list<value> }

	/// A result of a query
	record query-result {
		/// The names of the columns retrieved in the query
		columns: list<string>,
		/// the row results each containing the values for all the columns for a given row
		rows: list<row-result>,
	}

	/// Open a connection to a named database instance.
	///
	/// If `database` is "default", the default instance is opened.
	///
	/// `error::no-such-database` will be raised if the `name` is not recognized.
	open: func(database: string) -> result<connection, error>;

	/// Execute a statement returning back data if there is any
	execute: func(conn: connection, statement: string, parameters: list<value>) -> result<query-result, error>;

	/// Close the specified `connection`.
	close: func(conn: connection);
}

world http-trigger {
	import http-types;
	import config;
	import http;
	import rdbms-types;
	import postgres;
	import mysql;
	import sqlite;
	import redis-types;
	import redis;
	import key-value;
	import llm;
	export inbound-http;
}
